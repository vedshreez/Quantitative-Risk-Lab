# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11rEtO38Ro8e3sxEVhALGYJ4tAmhnmvns
"""

# 1. Install (Run this if you haven't yet)
!pip install yfinance

# 2. Import
import yfinance as yf
import pandas as pd
import numpy as np

# 3. Define Portfolio
tickers = ['AAPL', 'MSFT', 'TLT', 'GLD', 'SPY']
start_date = '2020-01-01'
end_date = '2025-01-01'

def fetch_data(tickers, start, end):
    print(f"Fetching data for: {tickers}...")

    # DOWNLOAD EVERYTHING FIRST
    # We do not use ['Adj Close'] immediately here to avoid the error
    data = yf.download(tickers, start=start, end=end)

    # CHECK WHICH COLUMN EXISTS
    # If 'Adj Close' is missing, use 'Close' (it is often the same in newer versions)
    if 'Adj Close' in data.columns.get_level_values(0):
        prices = data['Adj Close']
    else:
        print("'Adj Close' not found, using 'Close' instead.")
        prices = data['Close']

    # Fill missing values
    if prices.isnull().values.any():
        print("Missing values detected. Filling with forward fill...")
        prices = prices.ffill()

    print("Data fetched successfully!")
    return prices

def calculate_returns(data):
    # Log Returns
    log_returns = np.log(data / data.shift(1))
    log_returns = log_returns.dropna()
    return log_returns

# 4. Run it
prices = fetch_data(tickers, start_date, end_date)
returns = calculate_returns(prices)

# 5. Check
print("\n--- HEAD OF RETURNS DATA ---")
print(returns.head())

# 6. Save
prices.to_csv('portfolio_prices.csv')
returns.to_csv('portfolio_returns.csv')
print("\nDay 1 Task Complete: Files saved.")

# 1. Install Library
!pip install yfinance

# 2. Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

# ==========================================
# PART 1: FRESH DATA INGESTION (The Fix)
# ==========================================
tickers = ['AAPL', 'MSFT', 'TLT', 'GLD', 'SPY']
start_date = '2020-01-01'
end_date = '2025-01-01'

print("Step 1: Downloading fresh data...")
# Download with auto-adjust to avoid the "Adj Close" error
data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)

# Handle different yfinance versions (sometimes it returns 'Close' sometimes 'Adj Close')
if 'Close' in data.columns:
    prices = data['Close']
else:
    prices = data # Fallback

# Fill missing values to prevent dropping everything
prices = prices.ffill().bfill()

# Calculate Returns
returns = np.log(prices / prices.shift(1)).dropna()

# SAFETY CHECK: Stop if data is still empty
if returns.empty:
    raise ValueError("CRITICAL ERROR: Data download failed. The returns dataframe is empty.")

print(f"Success! Loaded {len(returns)} days of data.")

# ==========================================
# PART 2: THE RISK MODEL (VaR)
# ==========================================

# Create an "Equally Weighted" Portfolio (Average of all stocks)
returns['Portfolio'] = returns.mean(axis=1)

# Inputs
confidence_level = 0.95
investment_amount = 100000  # $100,000

def calculate_historical_var(returns, confidence=0.95):
    """
    Method 1: Historical Simulation
    """
    # Calculate the percentile (e.g., 5th percentile for 95% confidence)
    var_percentile = np.percentile(returns, (1 - confidence) * 100)
    return var_percentile

def calculate_parametric_var(returns, confidence=0.95):
    """
    Method 2: Parametric (Normal Distribution)
    """
    mu = np.mean(returns)
    sigma = np.std(returns)
    z_score = norm.ppf(1 - confidence)
    var

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

# --- PART 1: SETUP ---
tickers = ['AAPL', 'MSFT', 'TLT', 'GLD', 'SPY']
start_date = '2020-01-01'
end_date = '2024-01-01'

print("Fetching data...")
# UPDATED LINE BELOW: We explicitly ask for 'Close' because auto_adjust is True
data = yf.download(tickers, start=start_date, end=end_date)['Close']

# 2. Calculate Daily Returns
# (We use 'Close' now, which serves the same purpose as the old 'Adj Close')
returns = np.log(data / data.shift(1)).dropna()

# 3. Define Weights
weights = np.array([0.2, 0.2, 0.2, 0.2, 0.2])

# --- PART 2: MONTE CARLO SIMULATION ---

def calculate_monte_carlo_var(returns, weights, initial_investment=10000,
                              days=1, simulations=10000, confidence_level=0.95):
    """
    Calculates VaR using Monte Carlo Simulation with Cholesky Decomposition.
    """
    # Calculate Mean and Covariance Matrix
    mean_returns = returns.mean()
    cov_matrix = returns.cov()

    # Cholesky Decomposition (L)
    L = np.linalg.cholesky(cov_matrix)

    # Generate Random Noise (Z)
    Z = np.random.normal(0, 1, (len(weights), simulations))

    # Apply Correlation (L * Z)
    correlated_returns = np.dot(L, Z)

    # Simulate Portfolio Returns
    # Transpose mean_returns to match shape for broadcasting
    # Note: Depending on pandas version, mean_returns might need .values or explicit reshaping
    # We use .values.reshape(-1, 1) to be safe across versions
    simulated_returns = mean_returns.values.reshape(-1, 1) + correlated_returns

    # Calculate Portfolio Value Changes
    portfolio_sim_returns = np.dot(weights, simulated_returns)

    # Calculate VaR
    var_percentile = np.percentile(portfolio_sim_returns, (1 - confidence_level) * 100)
    var_value = initial_investment * -var_percentile

    return var_value, portfolio_sim_returns

# --- PART 3: EXECUTION ---

print("Running Monte Carlo Simulation...")
mc_var, sim_results = calculate_monte_carlo_var(returns, weights)

print(f"\n--- Day 3 Results ---")
print(f"Monte Carlo VaR (95% Confidence): ${mc_var:.2f}")

# Visualization
plt.figure(figsize=(10, 6))
plt.hist(sim_results, bins=50, alpha=0.7, color='purple', label='Simulated Returns')
plt.axvline(np.percentile(sim_results, 5), color='r', linestyle='dashed', linewidth=2, label='VaR (95%)')
plt.title('Monte Carlo Simulation of Portfolio Returns')
plt.xlabel('Return')
plt.ylabel('Frequency')
plt.legend()
plt.show()